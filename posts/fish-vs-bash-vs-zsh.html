<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Fish vs Bash vs Zsh - Blog post">
    <meta name="keywords" content="blog, article, Fish vs Bash vs Zsh">
    <meta name="author" content="My Blog">
    <meta property="og:title" content="Fish vs Bash vs Zsh">
    <meta property="og:description" content="Fish vs Bash vs Zsh - Blog post">
    <meta property="og:type" content="article">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Fish vs Bash vs Zsh">
    <meta name="twitter:description" content="Fish vs Bash vs Zsh - Blog post">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link rel="manifest" href="../data/manifest.json">
    <title>Fish vs Bash vs Zsh</title>
    <link rel="icon" type="image/png" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3Eüìù%3C/text%3E%3C/svg%3E">
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XXXXXXXXXX');
    </script>

    <link rel="stylesheet" href="../styles/posts.css">
</head>
<body>
    <a href="../index.html" class="back-link">‚Üê Back to home</a>
    <article>
        <h1>Fish vs Bash vs Zsh</h1>
<h2>The Uncomfortable Truth</h2>
<p>Bash isn't good. It's just old and everywhere. There's a difference.</p>
<p>You know what else was everywhere? Internet Explorer 6. Doesn't mean it was good. Doesn't mean we should have kept using it.</p>
<p>Fish is better. Not "different." Not "a matter of preference." <strong>Better.</strong> And the only reason you're still using Bash is inertia and Stockholm syndrome.</p>
<h2>What Bash Actually Is</h2>
<p>Bash is a 35-year-old shell designed when:<br />
- 640KB was enough RAM for anyone<br />
- The internet didn't exist<br />
- "User experience" meant "doesn't crash"<br />
- Backward compatibility with sh from 1979 was critical</p>
<p>It shows.</p>
<h3>Bash's Greatest Hits:</h3>
<div class="codehilite"><pre><span></span><code><span class="c1"># Is this command correct? Who the fuck knows!</span>
<span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;value&quot;</span><span class="w"> </span><span class="o">]</span><span class="w">    </span><span class="c1"># Right</span>
<span class="o">[</span><span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;value&quot;</span><span class="o">]</span><span class="w">      </span><span class="c1"># Wrong</span>
<span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="w"> </span><span class="o">]</span><span class="w">      </span><span class="c1"># Wrong but looks right</span>
<span class="o">[[</span><span class="w"> </span><span class="nv">$var</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>value<span class="w"> </span><span class="o">]]</span><span class="w">     </span><span class="c1"># Also right (sometimes)</span>

<span class="c1"># Array syntax that makes sense to nobody</span>
<span class="nv">arr</span><span class="o">=(</span><span class="s2">&quot;a&quot;</span><span class="w"> </span><span class="s2">&quot;b&quot;</span><span class="w"> </span><span class="s2">&quot;c&quot;</span><span class="o">)</span>
<span class="nb">echo</span><span class="w"> </span><span class="si">${</span><span class="nv">arr</span><span class="p">[0]</span><span class="si">}</span><span class="w">          </span><span class="c1"># a</span>
<span class="nb">echo</span><span class="w"> </span><span class="nv">$arr</span><span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="w">            </span><span class="c1"># a0 (WHAT?)</span>
<span class="nb">echo</span><span class="w"> </span><span class="si">${</span><span class="nv">arr</span><span class="p">[@]</span><span class="si">}</span><span class="w">          </span><span class="c1"># All elements</span>
<span class="nb">echo</span><span class="w"> </span><span class="si">${#</span><span class="nv">arr</span><span class="p">[@]</span><span class="si">}</span><span class="w">         </span><span class="c1"># Length (obviously)</span>

<span class="c1"># Variable expansion that requires a PhD</span>
<span class="si">${</span><span class="nv">var</span><span class="k">:-</span><span class="nv">default</span><span class="si">}</span><span class="w">         </span><span class="c1"># Use default if unset</span>
<span class="si">${</span><span class="nv">var</span><span class="p">:=default</span><span class="si">}</span><span class="w">         </span><span class="c1"># Assign default if unset  </span>
<span class="si">${</span><span class="nv">var</span><span class="p">:?error</span><span class="si">}</span><span class="w">           </span><span class="c1"># Error if unset</span>
<span class="si">${</span><span class="nv">var</span><span class="p">:+alternate</span><span class="si">}</span><span class="w">       </span><span class="c1"># Use alternate if SET</span>
<span class="c1"># Who the fuck can remember this?</span>

<span class="c1"># Command substitution ambiguity</span>
<span class="sb">`</span><span class="nb">command</span><span class="sb">`</span><span class="w">               </span><span class="c1"># Old way</span>
<span class="k">$(</span><span class="nb">command</span><span class="k">)</span><span class="w">              </span><span class="c1"># New way</span>
<span class="c1"># Both work! Because consistency is for losers</span>
</code></pre></div>

<p>This isn't a shell. It's a hazing ritual.</p>
<h2>What Zsh Actually Is</h2>
<p>Zsh is Bash with plugins. That's it.</p>
<p>Oh, and Oh-My-Zsh, which is:<br />
- 400MB of git repo<br />
- Thousands of plugins you'll never use<br />
- Startup time measured in seconds<br />
- A framework for a shell (yes, really)<br />
- Cargo culting as a lifestyle</p>
<h3>The Zsh Sales Pitch:</h3>
<p>"Install Zsh! Then install Oh-My-Zsh! Then configure it! Then install these 47 plugins! Then tweak this config file! Then install these fonts! Then..."</p>
<p>Or, and hear me out: <strong>use a shell that works out of the box.</strong></p>
<h3>What You Actually Get With Zsh:</h3>
<ul>
<li>Mostly Bash syntax (still garbage)</li>
<li>Better tab completion (after plugins)</li>
<li>Themes (who gives a shit)</li>
<li>Startup time that makes you question your life choices</li>
<li>Configuration complexity that requires its own framework</li>
</ul>
<p>Zsh is Bash wearing makeup. Still Bash underneath.</p>
<h2>What Fish Actually Is</h2>
<p>Fish is a shell designed this century by people who gave a shit about usability.</p>
<p><strong>Design philosophy:</strong><br />
- Sane syntax by default<br />
- Things should work without configuration<br />
- Users shouldn't need to read documentation to do basic tasks<br />
- If it looks like it should work, it should work</p>
<p>Revolutionary concepts, apparently.</p>
<h2>Why Fish is Better (With Receipts)</h2>
<h3>1. Syntax That Doesn't Hate You</h3>
<p><strong>Bash:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;value&quot;</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;yes&quot;</span>
<span class="k">fi</span>

<span class="c1"># Or is it?</span>
<span class="k">if</span><span class="w"> </span><span class="o">[[</span><span class="w"> </span><span class="nv">$var</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;value&quot;</span><span class="w"> </span><span class="o">]]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;yes&quot;</span>
<span class="k">fi</span>

<span class="c1"># Wait, which brackets? How many? Spaces where?</span>
</code></pre></div>

<p><strong>Fish:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="k">test</span> <span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span>
    <span class="k">echo</span> <span class="s2">&quot;yes&quot;</span>
<span class="k">end</span>

<span class="c"># Or just:</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span> <span class="o">]</span>
    <span class="k">echo</span> <span class="s2">&quot;yes&quot;</span>
<span class="k">end</span>

<span class="c"># No semicolons. No &quot;then&quot;. No &quot;fi&quot;. Just logic.</span>
</code></pre></div>

<h3>2. Variables That Make Sense</h3>
<p><strong>Bash:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nv">var</span><span class="o">=</span><span class="s2">&quot;hello&quot;</span>
<span class="nb">echo</span><span class="w"> </span><span class="nv">$var</span><span class="w">           </span><span class="c1"># hello</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span><span class="w">         </span><span class="c1"># hello (but different sometimes)</span>
<span class="nb">echo</span><span class="w"> </span><span class="si">${</span><span class="nv">var</span><span class="si">}</span><span class="w">         </span><span class="c1"># hello (why the braces?)</span>
<span class="nv">arr</span><span class="o">=(</span>a<span class="w"> </span>b<span class="w"> </span>c<span class="o">)</span>
<span class="nb">echo</span><span class="w"> </span><span class="nv">$arr</span><span class="w">           </span><span class="c1"># a (just the first element, obviously)</span>
<span class="nb">echo</span><span class="w"> </span><span class="si">${</span><span class="nv">arr</span><span class="p">[@]</span><span class="si">}</span><span class="w">      </span><span class="c1"># All elements (obviously)</span>
</code></pre></div>

<p><strong>Fish:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">set</span> var <span class="s2">&quot;hello&quot;</span>
<span class="k">echo</span> <span class="nv">$var</span>           <span class="c"># hello (always)</span>
<span class="k">set</span> arr a b c
<span class="k">echo</span> <span class="nv">$arr</span>           <span class="c"># a b c (all elements, because that makes sense)</span>
<span class="k">echo</span> <span class="nv">$arr</span><span class="o">[</span>1<span class="o">]</span>        <span class="c"># a (arrays start at 1, like humans count)</span>
</code></pre></div>

<h3>3. Functions That Don't Make You Cry</h3>
<p><strong>Bash:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">function</span><span class="w"> </span>myfunction<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nb">local</span><span class="w"> </span><span class="nv">var</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span>
<span class="o">}</span>

<span class="c1"># Or is it?</span>
myfunction<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nb">local</span><span class="w"> </span><span class="nv">var</span><span class="o">=</span><span class="nv">$1</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="nv">$var</span>
<span class="o">}</span>

<span class="c1"># Both work! Consistency is overrated</span>
</code></pre></div>

<p><strong>Fish:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">function</span> myfunction
    <span class="k">echo</span> <span class="nv">$argv</span><span class="o">[</span>1<span class="o">]</span>
<span class="k">end</span>

<span class="c"># That&#39;s it. No ceremony. No local/global confusion.</span>
</code></pre></div>

<h3>4. Tab Completion That Actually Works</h3>
<p><strong>Bash:</strong> Press tab. Get list of every file in current directory. Good luck.</p>
<p><strong>Zsh:</strong> Works after you install Oh-My-Zsh and 5 plugins and wait 3 seconds for them to load.</p>
<p><strong>Fish:</strong> <br />
- Suggests commands from your history (in grey)<br />
- Suggests file paths (intelligently)<br />
- Right arrow to accept suggestion<br />
- Works immediately after install<br />
- No configuration needed</p>
<h3>5. Error Messages That Help</h3>
<p><strong>Bash:</strong></p>
<div class="codehilite"><pre><span></span><code>$<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;value&quot;</span><span class="w"> </span><span class="o">]</span>
bash:<span class="w"> </span>syntax<span class="w"> </span>error<span class="w"> </span>near<span class="w"> </span>unexpected<span class="w"> </span>token<span class="w"> </span><span class="sb">`</span><span class="k">fi</span><span class="err">&#39;</span>
<span class="c1"># Gee, thanks. Very helpful.</span>
</code></pre></div>

<p><strong>Fish:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nv">$ </span><span class="k">if</span> <span class="k">test</span> <span class="s2">&quot;</span><span class="nv">$var</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span>
<span class="nb">fish</span>: Expected <span class="s1">&#39;end&#39;</span> to close <span class="s1">&#39;if&#39;</span> <span class="k">block</span>
<span class="c"># Oh, I forgot &#39;end&#39;. Clear. Helpful.</span>
</code></pre></div>

<h3>6. Startup Time That Doesn't Suck</h3>
<div class="codehilite"><pre><span></span><code>Bash with plugins: ~500ms
Zsh with Oh-My-Zsh: 2-5 seconds (yes, seconds)
Fish: ~50ms

Opening a new terminal should not require patience.
</code></pre></div>

<h2>"But POSIX Compliance!"</h2>
<p>Shut up.</p>
<p>POSIX compliance is about scripts, not interactive shells. And you know what?</p>
<p><strong>Your interactive shell doesn't need to be POSIX compliant.</strong></p>
<p>Scripts? Sure, write them in Bash/sh for portability. But your daily driver? Why are you punishing yourself for "compliance" that doesn't matter?</p>
<p>It's like saying "I only use Internet Explorer because it's the standard." The standard can be wrong.</p>
<h2>"But My Scripts!"</h2>
<p>Fish isn't trying to run your Bash scripts. That's not the point.</p>
<p>You can:<br />
1. Keep using bash for scripts (#!/bin/bash)<br />
2. Write new scripts in fish (#!/usr/bin/fish)<br />
3. Use bash-wrapper for legacy scripts<br />
4. Gradually migrate (or don't)</p>
<p>Your shell ‚â† your scripting language.</p>
<p>I use fish interactively. I write scripts in Python or Bash when needed. It's called separation of concerns. Look it up.</p>
<h2>"But Portability!"</h2>
<p>You're not porting your interactive shell.</p>
<p>When you SSH into a server, it has bash. So what? You use bash there. Fish is for your local machine where you can install what you want.</p>
<p>This isn't 1995. You're allowed to have different environments on different machines.</p>
<h2>"But Muscle Memory!"</h2>
<p>You learned Bash's insane syntax. You can learn Fish's sane syntax.</p>
<p>One is worth learning. The other is just Stockholm syndrome.</p>
<p>How long did it take you to remember <code>${var:=default}</code> vs <code>${var:-default}</code>? Now compare that to Fish's approach: it just works how you'd expect.</p>
<h2>What About Zsh?</h2>
<p>Zsh is the compromise for people who:<br />
- Know Bash is terrible<br />
- Want something better<br />
- But are too scared to actually change</p>
<p>It's Bash with a paint job. Better than Bash? Sure. But it's still fundamentally Bash's broken syntax with plugins duct-taped on.</p>
<p>Oh-My-Zsh is particularly offensive:<br />
- 400MB git repo for a shell configuration<br />
- Startup time longer than some OS boots<br />
- Requires constant maintenance<br />
- Treats symptoms, not the disease</p>
<h3>The Zsh Pitch:</h3>
<p>"You can configure it to be almost as good as Fish!"</p>
<h3>The Fish Reality:</h3>
<p>"It's already that good. No configuration needed."</p>
<h2>Real-World Comparison</h2>
<h3>Task: Navigate to a directory and list files</h3>
<p><strong>Bash:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nb">cd</span><span class="w"> </span>~/projects/my-project/src/components
ls<span class="w"> </span>-la
<span class="c1"># Hope you typed everything right</span>
<span class="c1"># No suggestions, no help</span>
</code></pre></div>

<p><strong>Fish:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">cd</span> ~/pr<span class="o">[</span>TAB<span class="o">]</span>           <span class="c"># Completes to ~/projects/</span>
<span class="k">cd</span> ~/projects/my-<span class="o">[</span>TAB<span class="o">]</span>  <span class="c"># Shows all matching directories</span>
<span class="k">cd</span> ~/projects/my-project/src/comp<span class="o">[</span>TAB<span class="o">]</span>
ls -la
<span class="c"># Or just: ls -la ~/pr[TAB through options]</span>
</code></pre></div>

<h3>Task: Find command from history</h3>
<p><strong>Bash:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c1"># Press Ctrl+R</span>
<span class="c1"># Type partial command</span>
<span class="c1"># Hope you remember exactly how you typed it</span>
<span class="c1"># Navigate through matches with more Ctrl+R</span>
<span class="c1"># Give up and type it again</span>
</code></pre></div>

<p><strong>Fish:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="c"># Start typing command</span>
<span class="c"># See suggestions in grey from history</span>
<span class="c"># Press right arrow to accept</span>
<span class="c"># Or keep typing to refine</span>
</code></pre></div>

<h3>Task: Check if variable is set</h3>
<p><strong>Bash:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span>-z<span class="w"> </span><span class="si">${</span><span class="nv">var</span><span class="p">+x</span><span class="si">}</span><span class="w"> </span><span class="o">]</span><span class="p">;</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;var is unset&quot;</span>
<span class="k">else</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;var is set&quot;</span>
<span class="k">fi</span>
<span class="c1"># Who the fuck writes this and thinks &quot;perfect&quot;?</span>
</code></pre></div>

<p><strong>Fish:</strong></p>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="k">set</span> -q var
    <span class="k">echo</span> <span class="s2">&quot;var is set&quot;</span>
<span class="k">else</span>
    <span class="k">echo</span> <span class="s2">&quot;var is unset&quot;</span>
<span class="k">end</span>
<span class="c"># Readable. Logical. Humane.</span>
</code></pre></div>

<h2>The Real Reasons People Don't Switch</h2>
<p>Let's be honest:</p>
<ol>
<li>
<p><strong>Inertia</strong>: You've used Bash for years. Change is scary.</p>
</li>
<li>
<p><strong>Cargo culting</strong>: "Real programmers use Bash" (said by people who can't remember array syntax without googling)</p>
</li>
<li>
<p><strong>Fear</strong>: "What if I need Bash somewhere?" (You will. You'll use it there. So what?)</p>
</li>
<li>
<p><strong>Elitism</strong>: "Fish is for noobs who can't handle real shells" (Translation: "I suffered learning this broken syntax, so you should too")</p>
</li>
<li>
<p><strong>Advice from 2005</strong>: Following blog posts from when Bush was president</p>
</li>
</ol>
<p>None of these are good reasons.</p>
<h2>What You Should Do</h2>
<h3>If You're New to Linux:</h3>
<p><strong>Start with Fish.</strong> Why learn broken syntax first?</p>
<p>Install:</p>
<div class="codehilite"><pre><span></span><code>sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>fish<span class="w">  </span><span class="c1"># Debian/Ubuntu</span>
sudo<span class="w"> </span>dnf<span class="w"> </span>install<span class="w"> </span>fish<span class="w">  </span><span class="c1"># Fedora</span>
brew<span class="w"> </span>install<span class="w"> </span>fish<span class="w">      </span><span class="c1"># macOS</span>
</code></pre></div>

<p>Set as default:</p>
<div class="codehilite"><pre><span></span><code>chsh<span class="w"> </span>-s<span class="w"> </span>/usr/bin/fish
</code></pre></div>

<p>Done. No configuration needed. It just works.</p>
<h3>If You're Using Bash:</h3>
<p>Try Fish for a week. Actually try it. Not "open it once and go back to Bash because different."</p>
<p>If after a week you genuinely prefer Bash's syntax to Fish's, fine. At least you made an informed choice instead of defending the status quo out of habit.</p>
<h3>If You're Using Zsh + Oh-My-Zsh:</h3>
<p>You're already willing to use non-Bash. You already wanted something better. You just chose the halfway solution.</p>
<p>Fish does what you wanted Zsh + 47 plugins to do, but out of the box.</p>
<h2>What I Actually Use</h2>
<p>I use Fish for interactive shells. Have for years.</p>
<p>I write scripts in:<br />
- Python (when I need real logic)<br />
- Bash (when I need one-liners for servers)<br />
- Fish (when it's for my local setup)</p>
<p>This isn't complicated. Different tools for different jobs.</p>
<h2>The "But" Counter-Arguments</h2>
<p><strong>"But I need to use Bash on servers"</strong><br />
So use Bash on servers. Fish doesn't delete Bash.</p>
<p><strong>"But my coworkers use Bash"</strong><br />
They can keep using Bash. Your shell choice doesn't affect them.</p>
<p><strong>"But I need to understand Bash for debugging"</strong><br />
Using Fish doesn't erase your Bash knowledge.</p>
<p><strong>"But scripts"</strong><br />
Scripts have shebangs. They run in the interpreter they specify. Your interactive shell is irrelevant.</p>
<p><strong>"But plugins/themes"</strong><br />
Fish has plugins if you want them. But unlike Zsh, you don't NEED them for basic functionality.</p>
<p><strong>"But configuration"</strong><br />
Fish needs less configuration than Bash or Zsh. That's the point.</p>
<p><strong>"But compatibility"</strong><br />
With what? Your muscle memory? Get new muscle memory.</p>
<h2>The Bottom Line</h2>
<p>Bash is old, broken, and maintained for backward compatibility with 1970s sh.</p>
<p>Zsh is Bash with plugins that try to fix Bash by being more Bash.</p>
<p>Fish is a shell designed for humans who don't enjoy suffering.</p>
<p><strong>You don't need to be POSIX-compliant in your interactive shell.</strong><br />
<strong>You don't need to match server environments on your laptop.</strong><br />
<strong>You don't need to use the same tools as everyone else.</strong></p>
<p>Use tools that work well. Fish works well.</p>
<h2>What I'm NOT Saying</h2>
<p>I'm not saying Bash is useless. It's everywhere and scriptable and fine for that.</p>
<p>I'm not saying Zsh is terrible. It's better than Bash.</p>
<p>I'm not saying Fish is perfect. Nothing is.</p>
<p>I AM saying:<br />
- <strong>Fish has better defaults than Bash or Zsh</strong><br />
- <strong>Better syntax for interactive use</strong><br />
- <strong>Better UX out of the box</strong><br />
- <strong>The only reason you're not using it is inertia</strong></p>
<h2>Try It Right Now</h2>
<p>Open a terminal. Type:</p>
<div class="codehilite"><pre><span></span><code>sudo<span class="w"> </span>apt-add-repository<span class="w"> </span>ppa:fish-shell/release-4
sudo<span class="w"> </span>apt<span class="w"> </span>update
sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>fish
</code></pre></div>

<p>Use it for 10 minutes. Just 10 minutes.</p>
<p>If after 10 minutes you think Bash's syntax is clearer and the UX is better, fine. Go back to Bash.</p>
<p>But I bet you won't.</p>
<hr />
<p><strong>Stop using Bash because "that's what everyone uses."</strong></p>
<p><strong>Stop using Zsh because you installed Oh-My-Zsh once and committed.</strong></p>
<p><strong>Start using tools that respect your time and don't require a PhD in syntax edge cases.</strong></p>
<p>Fish is better. The only question is how long you'll keep pretending it isn't.</p>
    </article>
    <footer>
        <p>Made with love ‚ù§Ô∏è 2025 | <a href="https://linkedin.com/in/yourprofile" target="_blank" rel="noopener noreferrer">LinkedIn Profile</a></p>
    </footer>
    <button class="back-to-top" id="backToTop" onclick="scrollToTop()" title="Back to top">‚Üë</button>
    
    <script>
        // Back to top button functionality
        const backToTopButton = document.getElementById('backToTop');
        
        window.addEventListener('scroll', () => {
            if (window.pageYOffset > 300) {
                backToTopButton.classList.add('visible');
            } else {
                backToTopButton.classList.remove('visible');
            }
        });
        
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
    </script>
</body>
</html>